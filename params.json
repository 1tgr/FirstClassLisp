{"name":"First Class Lisp","body":"### First Class Lisp\r\n\r\nFirst Class Lisp is a 'toy' Lisp interpreter written in C#.\r\n\r\nIt's main features are:\r\n\r\n* Pattern matching lambda\r\n* First class macros\r\n* First class continuations\r\n* Properly tail recursive\r\n\r\n### Pattern-matching lambda\r\n\r\nIn my previous experiences writing Scheme code, I ended up doing this a lot:\r\n\r\n```\r\n(cond ((pair? x)\r\n       (let ((head (car x)\r\n           tail (cdr x))\r\n          (do-something with head and tail)))\r\n      (#t (do-the-default-thing)))\r\n```\r\n\r\nIt's quite tedious - you go to all the trouble of checking if something is a pair, only to have to do it again to 'extract' out the bits that you want.\r\n\r\nAt the same time, to implement even the standard 'lambda' argument syntax, you have to support all of:\r\n```\r\n(lambda x ...) ' list args\r\n(lambda (a b) ...) ' positional args\r\n(lambda (a b . c) ...) ' some combination\r\n```\r\n\r\nBy the time you've implemented these three cases and written error handling code, it's arguably no more complicated to add the vastly more powerful pattern matching and 'case lambda' support.\r\n\r\nI was really happy with the results. For example, the quasiquote macro was vastly simpler to write:\r\n\r\n```\r\n(define expand-quasiquote\r\n    (lambda\r\n        (('unquote e))\r\n            e\r\n        ((('unquote-splicing x) . y))\r\n            (list append x (expand-quasiquote y))\r\n        ((x . y))\r\n            (list cons (expand-quasiquote x) (expand-quasiquote y))\r\n        x\r\n            (cons quote x)))\r\n(define quasiquote\r\n    (macro expand-quasiquote))\r\n```\r\n\r\n### Why first class macros?\r\n\r\nI wanted to have macros in my Lisp interpreter - but I didn't want to implement fully-fledged Scheme hygienic macros (\"syntax-rules\"), which I still find difficult to understand, let alone implement!\r\n\r\nFirst class macros provided an easy but elegant way to solve the \"hygiene\" problem.\r\n\r\nIn a conventional lisp you might define, say, a \"let\" macro as follows:\r\n\r\n```\r\n(define-macro let (var value body)\r\n    `(lambda (,var) ,body) ,value))\r\n```\r\n\r\nThis would expand:\r\n\r\n```\r\n(let x 5 (* x x))\r\n```\r\ninto\r\n```\r\n((lambda (x) (* x x) 5)\r\n```\r\n\r\nThis can cause problems though in that we are relying on 'lambda' not having some alternative meaning in the scope in which the let statement was expanded\r\n```\r\n(define (energy lambda)\r\n (with (c speed-of-light\r\n        h plancks-constant)\r\n  (/ (* c h) lambda)))\r\n```\r\n\r\nI got the above example from [Matt Might's page on first class macros](http://matt.might.net/articles/metacircular-evaluation-and-first-class-run-time-macros/) which I found to be very interesting reading on all of this. In fact, Matt's page was my original inspiration for implementing macros this way.\r\n\r\nIn First Class Lisp, the 'let' macro is very similar to the one I described earlier, but with one small change:\r\n```\r\n(define-macro let (var value body)\r\n    `(,lambda (,var) ,body) ,value))\r\n```\r\n\r\nSee the \",\" before lambda? This is how we solve the hygiene problem: we are unquoting 'lambda' to evaluate it in the environment of the macro expansion rather than the 'calling' context.\r\n\r\nThis is made possible by the fact that *all* 'special forms' are actually just [fexprs](http://en.wikipedia.org/wiki/Fexpr) defined in the current lexical environment. Our macros are just special cases of these f-expressions (except macros do not have access to the environment itself to perform their expansion).\r\n\r\nBecause all of these objects are mapped to names in the current environment, they can be passed and returned from functions like ordinary objects:\r\n\r\n```\r\n(with (identity (lambda (x) x))\r\n           ((identity let) x 3\r\n                (* x x)))\r\n```\r\n\r\nMy Lisp interpreter doesn't currently let you define your own f-expressions - only your own macros. Also, 'apply', in my Lisp interpreter, is a normal function - it doesn't work with macros or f-expressions. One could enhance it to support this, but this would mean that 'apply' itself could no longer be a function... I wasn't sure if I wanted to go all the way in this direction.\r\n\r\nHowever, for an example of someone who *has* gone all the way down the rabbit-hole in this direction, I recommend checking out this article about [Kernel](http://mainisusuallyafunction.blogspot.co.uk/2012/04/scheme-without-special-forms.html).\r\n\r\nSo, that might be the next interesting project: Change \"First Class Lisp\" to be a .Net \"Kernel\" interpreter.\r\n\r\n### First class continuations\r\n\r\nThe simplest way to implement an interpreter is to recursively visit the expression-tree, collecting\r\nup the terms.\r\n\r\nFor example, to implement some sort of arithmetic expression evaluator, you'd usually do something like this:\r\n\r\n```\r\ninterface IExpression\r\n{\r\n    double evaluate(Environment e);\r\n}\r\n\r\nclass Multiply : IExpression\r\n{\r\n    IExpression left;\r\n    IExpression right;\r\n    public double evaluate(Environment e)\r\n    {\r\n        return left.evaluate(e) * right.evaluate(e);\r\n    }\r\n}\r\n```\r\n\r\nIn fact, if you look at the GitHub history, you'll see that I started First Class Lisp in this exact way. It's very simple because you are using the implicit runtime stack to keep track of 'where you are'.\r\n\r\nAlthough it's simple, there are two disadvantages to the implicit approach:\r\n\r\n1. Properly 'tail recursive' programs in Lisp ideally should be able to loop in constant space. The implicit approach, however, will encounter stack overflow errors.\r\n2. You can't implement proper continuations which are implemented as pure 'first class' objects.\r\n\r\nTo resolve these issues, my approach was to use two \"stacks\" to keep track of the current interpreter state:\r\n\r\n1. A stack of 'tasks' that still need to be performed\r\n2. A stack of results which have been calculated\r\n\r\nWe start by pushing the task 'evaluate the expression' on the stack. We then repeatedly pull the top\r\n'task' off the stack and execute it, until there are no more tasks. Once a 'task' has been fully evaluated, the result should be on the result stack. The trick is, the evaluation of a task can trigger *further* tasks to be evaluated, and intermediate results can be pushed onto the result stack in the mean time.\r\n\r\nThe approach is essentially the same as the [Shunting Yard Algorithm](http://en.wikipedia.org/wiki/Shunting-yard_algorithm).\r\n\r\nTo implement first-class continuations efficiently, only one other thing was required: which was to make the entire structure of both stacks *immutable*:\r\n\r\n```\r\n    public interface Continuation\r\n    {\r\n        Continuation PushTask(Task task);\r\n        Continuation PopTask();\r\n        Continuation PushResult(Datum d);\r\n        Continuation PopResult();\r\n        // The current task\r\n        Task Task { get; }\r\n        // The current result\r\n        Datum Result { get; }\r\n    }\r\n```\r\n\r\nThis made it safe to pass the structure around, keep it as a variable and so on.\r\n\r\nTo 'prove' that it all works: I adapted [Matt Might's implementation of the 'amb' operator](http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/) and implemented it inside First Class Lisp:\r\n\r\n```\r\n(ambTest (4 3 5)\r\n    (begin\r\n        ; '404' for no solutions found. Haven't implemented\r\n        ; string literals so can't report anything else!!\r\n        (define error (lambda () 404))\r\n        (define env (make-amb-environment error))\r\n        (with (a (env 'amb '(1 2 3 4 5 6 7))\r\n               b (env 'amb '(1 2 3 4 5 6 7))\r\n               c (env 'amb '(1 2 3 4 5 6 7)))\r\n\r\n            (begin\r\n                ; We only want pythagorean triples\r\n                (env 'assert (eq? (* c c) (+ (* a a) (* b b))))\r\n                ; And only those with the second value less\r\n                ; than the first.\r\n                (env 'assert (<  b a))\r\n                (log (list a b c))))))\r\n```\r\n\r\n### Conclusion\r\n\r\nI have to say I've really enjoyed working on this project! I've particularly liked the experience of working with macros. Being able to write a macro any time I found myself writing some boiler plate code has been a trully addictive experience. I think I am getting hooked on Lisp!\r\n\r\nI'd welcome any feedback or suggestions.\r\n\r\nFeel free to make a fork of this repository to add your own enhancements or use this as the basis for some other cool project.\r\n","tagline":"A Lisp interpreter written in C# with first class macros and continuations","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}